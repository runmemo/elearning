<?php

/**
 * @file
 * course_outline.module provides a block that shows outline of the course
 */

/**
 * Implements hook_block_info()
 */
function course_outline_block_info() {
  $block['course_outline'] = array(
    'info' => t('Course Outline'),
      //  'cache' => DRUPAL_CACHE_PER_PAGE,
  );
  $block['course_certificate'] = array(
    'info' => t('Course Certificate'),
  );
  return $block;
}

/**
 * Implements hook_theme()
 */
function course_outline_theme() {
  return array(
    'menu_link__course_outline_unit' => array(
      'render element' => 'element'
    ),
    'course_outline_certifcate' => array(
      'variables' => array('variables' => NULL),
      'template' => 'course-outline-certifcate',
    ),
  );
}

/**
 * Returns HTML for the unit level elements of the course outline
 */
function theme_menu_link__course_outline_unit(array $variables) {
  $element = $variables['element'];
  $sub_menu = '';
  $output = '<h3 class="outline-unit js-outline-unit">' . $element['#title'] . '<span class="icon"></span></h3>';
  if ($element['#below']) {
    $sub_menu = drupal_render($element['#below']);
  }
  return $output . $sub_menu . "\n";
}

/**
 * Define the contents and title of the block/
 * Implementation of hook_block_view()
 *
 * Returns a renderable block array containing the current book's outline if
 * the node is part of a book.
 *
 * Returns NULL if the current menu item is not part of a book heirarchy.
 */
function course_outline_block_view($delta = '') {
  $book = course_node_book();
  if (!$book) {
    return NULL;
  }
  $block['subject'] = '';
  switch ($delta) {
    case 'course_outline':
      // Build course outline.
      drupal_add_js(drupal_get_path('module', 'course_outline') . '/course_outline.js');
      drupal_add_css(drupal_get_path('module', 'course_outline') . '/course_outline.css');
      drupal_add_library('system', 'ui.accordion');

      $tree = menu_tree_all_data($book['menu_name'], NULL, 3);
      $tree_key = key($tree);

      course_outline_preprocess_tree($tree);

      // If we pass 1 as the second param, we just get the top level node in the
      // book. Since the key will be the top level mlid, we'll have to use 
      // ['p1'] in the $book array (which contains the top mlid) when we use it 
      // for the block title.
      $book_name = book_toc($book['bid'], 1);

      $tree_output = menu_tree_output($tree);
      // Alter titles and classes of the links in the tree.
      course_outline_preprocess_tree($tree_output);

      // Build the block title and contents.
      $block['content'][] = $tree_output;
      break;

    case 'course_certificate' :
      // Build certificate block.
      $certificate = array();
      global $user;
      $course_node = node_load($book['bid']);
      if ($course_node) {
        $certificate['popup_description'] = course_outline_generate_grades_description($course_node);
        $certificate['user_credit'] = credit_calculate($course_node, $user);
        $certificate['points'] = t('@num points', array('@num' => $certificate['user_credit']));
        $certificate['pass_credit'] = credit_get_field_integer_value($course_node, 'field_pass_credit');
        if ($certificate['user_credit'] > $certificate['pass_credit']) {
          $certificate['class'] = 'certificate-enabled';
          $certificate['link'] = l(t('Download certificate'), 'node/' . $course_node->nid . '/certificate');
        }
        else {
          $certificate['class'] = 'certificate-disabled';
          $certificate['link'] = '<span class="certificate-disabled-text">' . t('Certificate unavailable') . '</span>';
        }
      }

      $certificate_output = array(
        '#type' => 'markup',
        '#markup' => theme('course_outline_certifcate', $certificate),
      );
      $block['content'][] = $certificate_output;
      break;
  }

  return $block;
}

/**
 * Adds content type specific html to leafs of course menu
 * @param array $tree represents menu tree
 * @return boolean
 */
function course_outline_preprocess_tree(&$tree) {
  global $user;
  $counter = new multi_counter;
  $tree_key = key($tree);
  if (isset($tree[$tree_key]['#below'])) {
    $tree = $tree[$tree_key]['#below']; // remove the top level
    $flag = flag_get_flag('course_item_complete');
    foreach ($tree as &$unit) {
      if (!isset($unit['#below'])) {
        continue;
      }
      // change theme for unit level links
      $unit['#theme'] = 'menu_link__course_outline_unit';
      // for each lesson we add html to the title
      foreach ($unit['#below'] as &$item) {
        if (!isset($item['#below'])) {
          continue;
        }
        $node = menu_get_object('node', 1, $item['#original_link']['link_path']);

        $completed = $flag->is_flagged($node->nid, $user->uid);
        $item['#attributes']['class'][] = 'outline-item';
        unset($item['#attributes']['class']['leaf']);
        $item['#attributes']['class'][] = $completed ? 'outline-item-is-complete' : 'outline-item-is-incomplete';
        if ($node->nid == arg(1)) {
          $item['#attributes']['class'][] = 'js-outline-current';
          $item['#attributes']['class'][] = 'outline-item-is-current';
        }
        $node->order = $counter->increment($node->type);

        $item['#title'] = course_outline_item_title($node);
        $item['#localized_options']['html'] = TRUE;
        $item['#attributes']['class'][] = $node->type;
      }
    }
  }
}

/**
 * Builds title for course outline menu item
 * @param object $node
 * @return string title for the course outline menu item
 */
function course_outline_item_title($node) {
  $title = "<span class='outline-" . str_replace('_', '-', $node->type) . "-icon'></span>";
  switch ($node->type) {
    case 'lesson':
      $title = $title . '<span class="outline-lesson-prefix">' . t('Lesson @i.', array('@i' => $node->order)) . '</span>';
      break;
  }
  $title = '<div class="title-wrapper">' . $title . $node->title . '</div>';
  return $title;
}

/**
 * Processes course node, collects grades info and build HTML with grades popup.
 * @param object $course
 * @return string HTML for popup description block
 */
function course_outline_generate_grades_description($course) {
  if ($cached = cache_get('course_grades_' . $course->nid, 'cache')) {
    $output = $cached->data;
    if ($output) {
      return $output;
    }
  }
  $grades_items = course_outline_process_grades($course);
  if (!empty($grades_items)) {
    $vars = array(
      'title' => t(''),
      'items' => $grades_items,
      'type' => 'ul',
      'attributes' => array(),
    );
    $list = theme_item_list($vars);
    $output = '<div class="outline-certificate-description">
    <div class="header">' . t('Compliance scores and marks for the certificate') . '</div>' .
      $list .
      '</div>';
    cache_set('course_grades_' . $course->nid, $output, 'cache', 24 * 60 * 60); //1 hour
  } else {
    $output = '';
  }
  return $output;
}

/**
 * Processes course grades and returns array with HTML in case of
 * 'course_outline' mode and name of necessary grade in case of 'certificate' mode.
 * @param object $course course node
 * @param string $mode case of using this function
 * @param float $credits user credits for the course
 * @return array/string Array with HTML or grade name
 */
function course_outline_process_grades($course, $mode = 'course_outline', $credits = 0) {
  $node_wrapper = entity_metadata_wrapper('node', $course);
  if (!$node_wrapper->field_grades->value()) {
    return '';
  }
  if ($mode == 'course_outline') {
    $items = array();
  } elseif ($mode == '') {
    $grade_name = 'certificate';
  }
  foreach ($node_wrapper->field_grades as $key => $grade) {
    $next = $key + 1;
    $grade_score_current = $node_wrapper->field_grades[$key]->field_grade_score->raw();
    $grade_score_next = isset($node_wrapper->field_grades[$next]) ? $node_wrapper->field_grades[$next]->field_grade_score->raw() : 0;
    if ($grade_score_next != 0) {
      if ($mode == 'course_outline') {
        $points = $key == 0 ? '0-' . $grade_score_current : $grade_score_current . '-' . $grade_score_next;
      } elseif ($mode == 'certificate') {
        if ($credits >= $grade_score_current && $credits < $grade_score_next) {
          $grade_name = $grade->field_grade_name->raw();
          break;
        }
      }
    } else {
      if ($mode == 'course_outline') {
        $points = '&gt; ' . $grade_score_current;
      } elseif ($mode == 'certificate') {
        if ($credits >= $grade_score_current) {
          $grade_name = $grade->field_grade_name->raw();
        }
      }
    }
    if ($mode == 'course_outline') {
      $desc = $key == 0 ? t('Certificate is not available') : $grade->field_grade_name->raw();
      $list_item = '<span class="points-range">' . t('!range points', array('!range' => $points)) . '</span>';
      $list_item .= ' - <span class="points-desc">' . $desc . '</span>';
      $items[] = $list_item;
    }
  }
  return $mode == 'course_outline' ? $items : $grade_name;
}

/**
 * Helper counter class allows to keep several counts
 */
class multi_counter {

  private $counts;

  public function __construct() {
    $this->counts = array();
  }

  /**
   * Increments counter of specific type by one
   * @param string $type
   * @return integer
   */
  public function increment($type) {
    if (!isset($this->counts[$type])) {
      return $this->counts[$type] = 1;
    }
    else {
      return++$this->counts[$type];
    }
  }

  /**
   * Gets current value of counter
   * @param string $type
   * @return integer
   */
  public function current($type) {
    if (!isset($this->counts[$type])) {
      return 0;
    }
    else {
      return $this->counts[$type];
    }
  }

}
