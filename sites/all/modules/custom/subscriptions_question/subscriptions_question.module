<?php

/**
 * @file
 * Code for the test feature.
 */

include_once 'subscriptions_question.features.inc';

/**
 * @file
 * Subscriptions to questions.
 *
 * subscriptions_question extends the subscription module to allow users to
 * subscribe questions. If a user subscribes to a question he will receive
 * notifications each time a answer is posted to that question. 
 */

/**
 * Implements hook_subscriptions().
 *
 * @param $op
 * @param null $arg0
 * @param null $arg1
 * @param null $arg2
 *
 * @return array|null
 *
 * @ingroup hooks
 */
function subscriptions_question_subscriptions($op, $arg0 = NULL, $arg1 = NULL, $arg2 = NULL) {
  static $stypes = array('question' => array('node', 'question_nid'));
  $function = '_subscriptions_question_' . $op;
  if (function_exists($function)) {
    return $function($arg0, $arg1, $arg2);
  }
  switch ($op) {
    case 'queue':
      // $arg0 is $event array.
      if ($arg0['module'] == 'node') {
        $node = $arg0['node'];
        $params['node']['question_nid'] = array(
          'join' => array('table' => 'field_data_field_answer_question', 'alias' => 'fs', 'on' => 's.value = fs.field_answer_question_nid'),
          'where' => array(array('fs.entity_id', $node->nid, '=')),
          'groupby' => 'fs.entity_id'
          ); 
        return $params;
      }
      break;

    case 'fields': // $arg0 is module.
      if ($arg0 == 'node') {
        return array(
          'question_nid' => array(
            'data_function' => 'subscriptions_content_data',
            'subs_mod' => 'subscriptions_content',
            'subs_type' => t('thread'),
            'mailkey' => 'node-type-',
          ),
        );
      }
      break;

    case 'stypes':
      return $stypes;

    case 'stype':
      return (isset($stypes[$arg0]) ? array_merge( $stypes[$arg0], array($arg1, $arg2)) : NULL);
  }
  return NULL;
}

/**
 * Implements _hook_node_options(), subhook of hook_subscriptions().
 *
 * This is called by subscriptions_ui_node_form() in subscriptions_ui.module.
 *
 * @param $account
 * @param $node
 *
 * @return array|null
 *
 * @ingroup form
 * @ingroup hooks
 *
 * @see subscriptions_ui_node_form()
 */
function _subscriptions_question_node_options($account, $node) {
  if (!user_access('subscribe to questions')) {
    return NULL;
  }
  $options = array();
  if ($node->type == 'question') {
    $options['question'][] = array(
      'name' => t('Subscribe to this question'),
      'params' => array('module' => 'node', 'field' => 'question_nid', 'value' => $node->nid),
      'link' => 'node/' . $node->nid,
    );
    $options['question']['weight'] = -4;
  }
  return $options;
}

/**
 * Implements _hook_types(), subhook of hook_subscriptions().
 *
 * This is called by subscriptions_types() in subscriptions.module.
 *
 * @return array
 *   Returns information about types for Subscriptions module interface.
 *
 * @ingroup form
 * @ingroup hooks
 *
 * @see subscriptions_types()
 */
function _subscriptions_question_types() {
  $types['question'] = array(
    'title'      => 'Questions',
    'page'       => 'subscriptions_question_page_question',
    // @todo barinder, lets rename field_answer_question to question_nid
    //
    // I guess you are right in terms of using default event from content_subscriptions
    'fields'     => array('node', 'question_nid'),
    'weight'     => -20,
    'access'     => 'subscribe to questions',
    'permission' => array(
      'title'       => t('Subscribe to questions'),
      'description' => t('Subscribe to the questions')
    ),
  );
  return $types;
}

/**
 * Returns a list of question subscriptions.
 *
 * @param array $form
 * @param int $uid
 *   ID of a user if >0 or of a role if <0.
 *
 * @return array
 *
 * @ingroup form
 */
function subscriptions_question_page_question(array $form, $uid) {
  _subscriptions_module_load_include('subscriptions_question', 'admin.inc');
  return _subscriptions_question_form($form, $uid);
}

/**
 * Implements hook_node_delete().
 *
 * Catches node deletes and remove any associated thread subscriptions.
 *
 * @param object $node
 */
function subscriptions_question_node_delete($node) {
  subscriptions_delete_for_all_users('node', 'question_nid', $node->nid);
}

/**
 * Implements hook_disable().
 *
 * Remove our queue items.
 *
 * @ingroup hooks
 */
function subscriptions_question_disable() {
  db_delete('subscriptions_queue')
    ->condition('module', 'node')
    ->condition('field', 'question_nid')
    ->execute();
}

/**
 * Implements hook_rules_action_info() on behalf of the node module.
 */
function subscriptions_question_rules_action_info() {
  $base = array(
    'type' => 'subscriptions',
    'parameter' => array(
      'node' => array('type' => 'node', 'label' => t('Question')),
      'user' => array('type' => 'user', 'label' => t('User')),
    ),
    'group' => t('Subscriptions'),
    'access callback' => 'subscriptions_question_add_user_content_access',
  );

  // Action subsribe a user to a content
  $items['subscriptions_question_add_user_content'] = array(
    'label' => t('Subscribe user to question'),
    'base' => 'subscriptions_question_add_user_content_callback',
  ) + $base;

  // Action unsubsribe a user to a content
  $items['subscriptions_question_remove_user_content'] = array(
    'label' => t('Unsubscribe user from question'),
    'base' => 'subscriptions_question_remove_user_content_callback',
  ) + $base;

  return $items;
}

/**
 * Rule subscriptions_add_user_content callback
 */
function subscriptions_question_add_user_content_callback($node, $user, $type = 'node') {
  // Get existed
  $sid = subscriptions_get_subscription($user->uid, 'node', 'question_nid', $node->nid);
  $args = array (
    0 => 'node',
    1 => 'question_nid',
    2 => $node->nid,
    3 => -1, // DEBUG $node->uid,
    4 => $user->uid,
  );

  if ($sid) {
    // Add more value to existed subscription_content row
    $update = db_update('subscriptions')
    ->condition('module', $args[0])
    ->condition('field', $args[1])
    ->condition('value', $args[2])
    ->condition('author_uid', $args[3])
    ->condition('recipient_uid', $args[4]);

    $ret = $update->execute();
  }
  else {
    $ret = call_user_func_array('subscriptions_write_subscription', $args);
  }

  return $ret;
}

/**
 * Rule subscriptions_remove_user_content callback
 */
function subscriptions_question_remove_user_content_callback($node, $user, $type = 'node') {
  $args = array (
    0 => 'node',
    1 => 'question_nid',
    2 => $node->nid,
    3 => -1, // DEBUG $node->uid,
    4 => $user->uid,
  );

  // Delete single rows
  $delete = db_delete('subscriptions')
    ->condition('module', $args[0])
    ->condition('field', $args[1])
    ->condition('value', $args[2])
    ->condition('author_uid', $args[3])
    ->condition('recipient_uid', $args[4]);

  $ret = $delete->execute();

  return $ret;
}

/**
 * TODO: user_access
 */
function subscriptions_question_add_user_content_access() {
  return TRUE;
}
