<?php

/**
 * @file
 * Code for the Newsfeed feature.
 */

/**
 * Implementes hook_hook_info().
 */
function newsfeed_hook_info() {
  $hooks['flag_default_flags']['group'] = 'flag_default';
  $hooks['default_message_type']['group'] = 'message_default';
  return $hooks;
}

/**
 * Implements hook_ctools_plugin_api().
 */
function newsfeed_ctools_plugin_api() {
  list($module, $api) = func_get_args();
  if ($module == "strongarm" && $api == "strongarm") {
    return array("version" => "1");
  }
  if ($module == 'message_notify' && $api == 'notifier') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_views_api().
 */
function newsfeed_views_api() {
  return array(
    'api' => '3.0',
    'path' => drupal_get_path('module', 'newsfeed') . '/views',);
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function newsfeed_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'message_notify' && $plugin_type == 'notifier') {
    return 'plugins/notifier/internal';
  }
}

/**
 * Implements hook_block_info().
 */
function newsfeed_block_info() {
  // Block for displaying notifications count.
  $block['newsfeed_notifications_count'] = array(
    'info' => t('Newsfeed notifications count'),
    'cache' => DRUPAL_NO_CACHE,
  );
  return $block;
}

/**
 * Implements hook_block_view().
 */
function newsfeed_block_view($delta = '') {
  if ($delta == 'newsfeed_notifications_count') {
    return newsfeed_notifications_block();
  }
}

/**
 * Generates notifications block for the current user if the user is logged in.
 * 
 * @return array
 *   Block's content array.
 */
function newsfeed_notifications_block() {
  global $user;
  if (!$user->uid) {
    return;
  }
  $unread_messages = newsfeed_get_unread_messages_count($user->uid);
  $title = $unread_messages == 0 ? t('You have no unread notifications') : t('Notifications');
  $class = $unread_messages > 99 ? 'newsfeed-link-font-small' : 'newsfeed-link-font-default';
  $class .= ' newsfeed-link';
  $class .= ' js-newsfeed-unread-count';
  $block = array('subject' => '');
  $block['content'] = array(
    '#type' => 'markup',
    '#markup' => 
      '<div class="newsfeed-link-border"></div>' . 
        l($unread_messages ,
          'notifications', array('attributes' => array('title' => $title, 'class' => array($class)), 'html' => TRUE)) . 
      '<div class="newsfeed-link-border"></div>',
  );
  return $block;
}


/**
 * Calculates number of unread messages for the user.
 * 
 * @param integer $uid
 *   User ID.
 * @return integer
 *   Number of unread messages.
 */
function newsfeed_get_unread_messages_count($uid) {
  if (!$uid) {
    return FALSE;
  }
  
  // @todo : possibly need to cache this on per user basis. 
  $query = db_select('message_user', 'mu');
  $query->leftJoin('flagging', 'f', 'mu.mid = f.entity_id');
  $query->condition('mu.uid', $uid);
  $query->isNull('f.uid');
  $query->addExpression('COUNT(*)', 'count');
  $db_result = $query->execute();
  $result = $db_result->fetch();

  return isset($result->count) ? $result->count : 0;
}

  /**
   * Checks for instance of newsfeed notification for a user.
   * 
   * @param integer $mid
   * @param integer $uid
   * @return boolean
   */
  function newsfeed_exists($mid, $uid) {
    $query = db_select('message_user', 'mu')->fields('mu', array('mid'))
      ->condition('uid', $uid)
      ->condition('mid', $mid);
    $db_result = $query->execute();
    $result = $db_result->fetch();

    return isset($result->mid);
  }

/**
 * Inserts new record in the table for message-user instances.
 * 
 * @param integer $mid
 *   Message ID.
 * @param integer $uid
 *   User ID.
 */
function newsfeed_insert($mid, $uid) {
  $record = array('mid' => $mid, 'uid' => $uid);
  drupal_write_record('message_user', $record);
}

/**
 * Removes all records for the given message ID
 * from the table for message-user instances.
 * 
 * @param integer $mid
 *   Message ID.
 */
function newsfeed_remove($mid) {
  db_delete('message_user')
    ->condition('mid', $mid)
    ->execute();
}

/**
 * Creates new message with given parameters.
 * 
 * @param string $type
 *   Type of the message
 * @param integer $uid
 *   User ID, to which to assgin message
 * @param object $node
 *   Node which is used to get the context ans list of subscribers
 * @param array $fields
 *   Values to place in corresponding fields
 * @param array $uids
 *   User IDs array. It's used in case of single recipient of the message
 * 
 */
function newsfeed_create_message($type, $uid, $node, $fields = array(), $uids = array()) {
  // Create message.
  $message = message_create($type, array('uid' => $uid));
  $wrapper = entity_metadata_wrapper('message', $message);
  
  // Set necessary fields to use with tokens.
  foreach ($fields as $name => $value) {
    $wrapper->$name->set($value);
  }
  $message->save();

  // Add parameters in order to avoid creating message for every subscriber.
  $notify_options = array(
    'internal' => array(
      'save on fail' => FALSE,
      'save on success' => FALSE,
      'mid' => $message->mid,
    )
  );
  $subscribe_options = array(
    'save message' => FALSE,
    'author' => $uid,
  );
  if (!empty($uids)) {
    $subscribe_options['uids'] = $uids;
  }

  return message_subscribe_send_message('node', $node, $message, $notify_options, $subscribe_options);
}

/**
 * Implements hook_message_subscribe_get_subscribers_alter().
 * 
 * Adds 'internal' notifier if it's not set yet.
 */
function newsfeed_message_subscribe_get_subscribers_alter(&$uids, $values) {
  if (empty($uids) || is_null($notifier = message_notify_get_notifier('internal'))) {
    return;
  }
  foreach ($uids as $uid => $options) {
    // Unset node author from receivers array.
    if (isset($values['subscribe_options']['author']) && $values['subscribe_options']['author'] == $uid) {
      unset($uids[$uid]);
      continue;
    }
    // Add internal notifier if it's not added yet.
    if (!isset($options['notifiers']['internal'])) {
      $uids[$uid]['notifiers']['internal'] = 'internal';
    }
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Handles message-user instance deletion when message is being deleted.
 */
function newsfeed_entity_delete($entity, $entity_type) {
  if ($entity_type == 'message') {
    newsfeed_remove($entity->mid);
  }
}

/**
 * Implements hook_init().
 */
function newsfeed_init() {
  if (arg(2) == 'blog' && is_numeric(arg(1))) {
    global $user;
    newsfeed_update_unread_messages('field_course', $user->uid, arg(1));
  }
  elseif (arg(0) == 'notifications') {
    drupal_add_js(drupal_get_path('module', 'newsfeed') . '/newsfeed.js');
  }
}


/**
 * Implements hook_node_view().
 */
function newsfeed_node_view($node, $view_mode, $langcode) {
  if ($node->type == 'question' || $node->type == 'open_question') {
    global $user;
    newsfeed_update_unread_messages('field_message_' . $node->type, $user->uid, $node->nid);
  }
}

/**
 * Finds related unread messages and updates their status.
 * 
 * @param string $field
 *   Message field name.
 * @param integer $uid
 *   User ID.
 * @param integer $nid
 *   Node ID.
 */
function newsfeed_update_unread_messages($field, $uid, $nid) {
  $unread_messages = newsfeed_get_related_unread_messages($field, $uid, $nid);
  if ($unread_messages) {
    foreach ($unread_messages as $mid) {
      flag('flag', 'message_read', $mid);
    }
  }
}

/**
 * Collects related unread messages.
 * 
 * @param string $field
 *   Message field name.
 * @param integer $uid
 *   User ID.
 * @param integer $nid
 *   Node ID.
 */
function newsfeed_get_related_unread_messages($field, $uid, $nid) {
  if (!$field) {
    return FALSE;
  }
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'message')
    ->fieldCondition($field, 'target_id', $nid)
    ->addMetaData('message_uid', $uid)
    ->addTag('newsfeed_related_message');
  $result = $query->execute();
  if ($result) {
    $result = array_keys($result['message']);
  }
  return !empty($result) ? $result : FALSE;
}

/**
 * Implements hook_query_TAG_alter() for 'newsfeed_related_message' tag.
 * 
 * Adds join for 'message_user' table in order to get user related messages.
 */
function newsfeed_query_newsfeed_related_message_alter(QueryAlterableInterface $query) {
  $base_alias = newsfeed_get_base_table_alias($query);
  $query->join('message_user', 'mu', $base_alias . '.entity_id = mu.mid');
  $query->leftJoin('flagging', 'f', $base_alias . '.entity_id = f.entity_id');
  $query->condition('mu.uid', $query->getMetaData('message_uid'));
  $query->isNull('f.uid');
}

function newsfeed_get_base_table_alias($query) {
  $base_table = $query->getMetaData('base_table');
  $tables = $query->getTables(); 
  foreach ($tables as $alias => $table) {
    if ($base_table === $table['table']) {
      return $alias;
    }
  }
  return FALSE;
}