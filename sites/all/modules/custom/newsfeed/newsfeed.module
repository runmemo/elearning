<?php

/**
 * @file
 * Code for the Newsfeed feature.
 */
include_once 'newsfeed.features.inc';

/**
 * Implements hook_ctools_plugin_api().
 */
function newsfeed_ctools_plugin_api() {
  list($module, $api) = func_get_args();
  if ($module == "strongarm" && $api == "strongarm") {
    return array("version" => "1");
  }
  if ($module == 'message_notify' && $api == 'notifier') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_views_api().
 */
function newsfeed_views_api() {
  return array("api" => "3.0");
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function newsfeed_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'message_notify' && $plugin_type == 'notifier') {
    return 'plugins/notifier/internal';
  }
}

/**
 * Implements hook_node_insert().
 */
function newsfeed_node_insert($node) {
  if (in_array($node->type, array('answer', 'open_question_feedback'))) {
    $author = user_load($node->uid);
    $node_wrapper = entity_metadata_wrapper('node', $node);
    if ($node->type == 'answer') {
      // Notify all question subscribers if new answer is posted.
      // Load question, in order to pass it to message_subscribe_send_message()
      // and get all question subscibers.
      $question = node_load($node_wrapper->field_answer_question->raw());
      $msg = t('User !user added !answer to the !question.', array(
        '!user' => l(format_username($author), 'user/' . $author->uid),
        '!answer' => l(t('answer'), 'node/' . $node_wrapper->field_answer_question->raw(), array('fragment' => 'answer-' . $node->nid)),
        '!question' => t('question') . ': ' . l('"' . $node_wrapper->field_answer_question->title->raw() . '"', 'node/' . $node_wrapper->field_answer_question->nid->raw())));
      newsfeed_create_message($author->uid, $msg, $question);
    } elseif ($node->type == 'open_question_feedback') {
      // Notify answer author about new feedback.
      $msg = t('User !user added !feedback to your answer to this question: !question.', array(
        '!user' => l(format_username($author), 'user/' . $author->uid),
        '!feedback' => l(t('feedback'), 'node/' . $node_wrapper->field_open_question_answer->field_open_question->value()->nid, array('fragment' => 'feedback-' . $node->nid)),
        '!question' => l('"' . $node_wrapper->field_open_question_answer->field_open_question->value()->title . '"', 'node/' . $node_wrapper->field_open_question_answer->field_open_question->value()->nid)));
      $uids = array(
        $node_wrapper->field_open_question_answer->value()->uid => array(
          'notifiers' => array(
            'internal' => 'internal'
          )
        )
      );
      newsfeed_create_message($author->uid, $msg, $node, $uids);
    }
  }
}

/**
 * Creates new message with given parameters.
 * 
 * @param integer $uid
 *   User ID, to which to assgin message
 * @param string $body
 *   Body of the message
 * 
 * @return Message $message
 *   Message object
 */
function newsfeed_create_message($uid, $body, $node, $uids = array()) {
  // Create message and save it with given body.
  $message = message_create('subscriptions_notification', array('uid' => $uid));
  $wrapper = entity_metadata_wrapper('message', $message);
  $wrapper->field_message_body->set(array('value' => $body, 'format' => 'filtered_html'));
  $message->save();

  // Add parameters in order to avoid creating message for every subscriber.
  $notify_options = array(
    'internal' => array(
      'save on fail' => FALSE,
      'save on success' => FALSE,
      'mid' => $message->mid,
    )
  );
  $subscribe_options = array(
    'save message' => FALSE,
    'author' => $uid,
  );
  if (!empty($uids)) {
    $subscribe_options['uids'] = $uids;
  }

  message_subscribe_send_message('node', $node, $message, $notify_options, $subscribe_options);
}

/**
 * Implements hook_message_subscribe_get_subscribers_alter().
 * 
 * Adds 'internal' notifier if it's not set yet.
 */
function newsfeed_message_subscribe_get_subscribers_alter(&$uids, $values) {
  if (empty($uids) || is_null($notifier = message_notify_get_notifier('internal'))) {
    return;
  }
  foreach ($uids as $uid => $options) {
    // Unset node author from receivers array.
    if (isset($values['subscribe_options']['author']) && $values['subscribe_options']['author'] == $uid) {
      unset($uids[$uid]);
      continue;
    }
    // Add internal notifier if it's not added yet.
    if (!isset($options['notifiers']['internal'])) {
      $uids[$uid]['notifiers']['internal'] = 'internal';
    }
  }
}

/**
 * Implements hook_comment_insert().
 * 
 * Creates notification message on commenting feedback.
 */
function newsfeed_comment_insert($comment) {
  $node = node_load($comment->nid);
  if ($node->type == 'open_question_feedback') {
    $node_wrapper = entity_metadata_wrapper('node', $node);
    $question_nid = $node_wrapper->field_open_question_answer->field_open_question->value()->nid;
    $main_url = 'node/' . $question_nid;
    if ($comment->uid == $node_wrapper->field_open_question_answer->value()->uid) {
      // If comment author is answer author, send message to feedback author.
      $uid = $node->uid;
      $actor_uid = $comment->uid;
      $pattern = 'User !user added !comment to your !feedback to this !answer_question.';
      $fragment = 'review-' . $node->nid;
      $comment_param = array('query' => array('comment' => $comment->cid));
      $answer_question = l(t('answer'), $main_url, array('fragment' => 'answer-' . $node_wrapper->field_open_question_answer->value()->nid));
    } elseif ($comment->uid == $node->uid) {
      // If comment author is feedback author, send message to answer author.
      $uid = $node_wrapper->field_open_question_answer->value()->uid;
      $actor_uid = $node->uid;
      $pattern = 'User !user added !comment to this !feedback to your answer to this question: !answer_question.';
      $fragment = 'feedback-' . $node->nid;
      $comment_param = array('fragment' => 'comment-' . $comment->cid);
      $answer_question = l('"' . $node_wrapper->field_open_question_answer->field_open_question->value()->title . '"', $main_url);
    } else {
      $uid = FALSE;
    }
    if ($uid) {
      $actor = user_load($actor_uid);
      $msg = t($pattern, array(
        '!user' => l(format_username($actor), 'user/' . $actor_uid),
        '!comment' => l(t('comment'), $main_url, $comment_param),
        '!feedback' => l(t('feedback'), $main_url, array('fragment' => $fragment)),
        '!answer_question' => $answer_question));
      $uids = array(
        $uid => array(
          'notifiers' => array(
            'internal' => 'internal'
          )
        )
      );
      newsfeed_create_message($actor_uid, $msg, $node, $uids);
    }
  }
}

/**
 * Creates instance between message and user.
 * 
 * @param integer $mid
 *   Message ID
 * @param integer $uid
 *   User ID
 * 
 * @return
 *   @see drupal_write_record().
 */
function newsfeed_create_instance($mid, $uid) {
  $record = array('mid' => $mid, 'uid' => $uid);
  $result = drupal_write_record('message_user', $record);
  return $result;
}

/**
 * Implements hook_entity_delete().
 *
 * Handles message-user instance deletion when message is being deleted.
 */
function newsfeed_entity_delete($entity, $entity_type) {
  if ($entity_type == 'message') {
    db_delete('message_user')
      ->condition('mid', $entity->mid)
      ->execute();
  }
}
