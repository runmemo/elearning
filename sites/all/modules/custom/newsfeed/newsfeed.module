<?php

/**
 * @file
 * Code for the Newsfeed feature.
 */

/**
 * Implementes hook_hook_info().
 */
function newsfeed_hook_info() {
  $hooks['flag_default_flags']['group'] = 'flag_default';
  $hooks['default_message_type']['group'] = 'message_default';
  return $hooks;
}

/**
 * Implements hook_ctools_plugin_api().
 */
function newsfeed_ctools_plugin_api() {
  list($module, $api) = func_get_args();
  if ($module == "strongarm" && $api == "strongarm") {
    return array("version" => "1");
  }
  if ($module == 'message_notify' && $api == 'notifier') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_views_api().
 */
function newsfeed_views_api() {
  return array("api" => "3.0");
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function newsfeed_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'message_notify' && $plugin_type == 'notifier') {
    return 'plugins/notifier/internal';
  }
}

/**
 * Implements hook_block_info().
 */
function newsfeed_block_info() {
  // Block for displaying notifications count.
  $block['user_notifications_count'] = array(
    'info' => t('User notifications count'),
    'cache' => DRUPAL_NO_CACHE,
  );
  return $block;
}

/**
 * Implements hook_block_view().
 */
function newsfeed_block_view($delta = '') {
  if ($delta == 'user_notifications_count') {
    return newsfeed_notifications_block();
  }
}

/**
 * Generates notifications block for the current user if the user is logged in.
 * 
 * @return array
 *   Block's content array.
 */
function newsfeed_notifications_block() {
  global $user;
  if (!$user->uid) {
    return;
  }
  $_SESSION['unread_messages_count'] = newsfeed_get_unread_messages_count($user->uid);
  $title = $_SESSION['unread_messages_count'] == 0 ? t('You have no unread notifications') : t('Notifications');
  $block = array('subject' => '');
  $block['content'] = array(
    '#type' => 'markup',
    '#markup' => l('<span id="js-newsfeed-unread-count" class="link-inner">' . $_SESSION['unread_messages_count'] . '</span>', 'notifications', array('attributes' => array('title' => $title), 'html' => TRUE)),
  );
  return $block;
}


/**
 * Calculates number of unread messages for the user.
 * 
 * @param integer $uid
 *   User ID.
 * @return integer
 *   Number of unread messages.
 */
function newsfeed_get_unread_messages_count($uid) {
  if (!$uid) {
    return FALSE;
  }
  $query = db_select('message_user', 'mu')
    ->condition('uid', $uid)
    ->condition('status', 0);
  $query->addExpression('COUNT(*)', 'count');
  $db_result = $query->execute();
  $result = $db_result->fetch();

  return isset($result->count) ? $result->count : 0;
}

/**
 * Inserts new record in the table for message-user instances.
 * 
 * @param integer $mid
 *   Message ID.
 * @param integer $uid
 *   User ID.
 * @param integer $status
 *   Message status.
 */
function newsfeed_insert($mid, $uid, $status = 0) {
  $record = array('mid' => $mid, 'uid' => $uid, 'status' => $status);
  drupal_write_record('message_user', $record);
}

/**
 * Removes all records for the given message ID
 * from the table for message-user instances.
 * 
 * @param integer $mid
 *   Message ID.
 */
function newsfeed_remove($mid) {
  db_delete('message_user')
    ->condition('mid', $mid)
    ->execute();
}

/**
 * Updates message status for the given user.
 * 
 * @param array $mids
 *   Array with message IDs.
 * @param integer $uid
 *   User ID.
 * @param integer $status
 *   New message status.
 */
function newsfeed_update_message_status_multiple($mids, $uid, $status) {
  $query = db_update('message_user')
    ->fields(array('status' => $status))
    ->condition('mid', $mids, 'IN')
    ->condition('uid', $uid)
    ->execute();
  return $query;
}

/**
 * Gets status of the given message.
 * 
 * @param integer $mid
 *   Message ID.
 * @param integer $uid
 *   User ID.
 * 
 * @return integer
 *   Message status.
 */
function newsfeed_get_message_status($mid, $uid) {
  $query = db_select('message_user', 'mu')
    ->fields('mu', array('status'))
    ->condition('mid', $mid)
    ->condition('uid', $uid);
  $db_result = $query->execute();
  $result = $db_result->fetch();
  
  return isset($result->status) ? $result->status : NULL;
}

/**
 * Creates new message with given parameters.
 * 
 * @param string $type
 *   Type of the message
 * @param integer $uid
 *   User ID, to which to assgin message
 * @param object $node
 *   Node which is used to get the context ans list of subscribers
 * @param array $fields
 *   Values to place in corresponding fields
 * @param array $uids
 *   User IDs array. It's used in case of single recipient of the message
 * 
 */
function newsfeed_create_message($type, $uid, $node, $fields = array(), $uids = array()) {
  // Create message.
  $message = message_create($type, array('uid' => $uid));
  $wrapper = entity_metadata_wrapper('message', $message);
  
  // Set necessary fields to use with tokens.
  foreach ($fields as $name => $value) {
    $wrapper->$name->set($value);
  }
  $message->save();

  // Add parameters in order to avoid creating message for every subscriber.
  $notify_options = array(
    'internal' => array(
      'save on fail' => FALSE,
      'save on success' => FALSE,
      'mid' => $message->mid,
    )
  );
  $subscribe_options = array(
    'save message' => FALSE,
    'author' => $uid,
  );
  if (!empty($uids)) {
    $subscribe_options['uids'] = $uids;
  }

  message_subscribe_send_message('node', $node, $message, $notify_options, $subscribe_options);
}

/**
 * Implements hook_message_subscribe_get_subscribers_alter().
 * 
 * Adds 'internal' notifier if it's not set yet.
 */
function newsfeed_message_subscribe_get_subscribers_alter(&$uids, $values) {
  if (empty($uids) || is_null($notifier = message_notify_get_notifier('internal'))) {
    return;
  }
  foreach ($uids as $uid => $options) {
    // Unset node author from receivers array.
    if (isset($values['subscribe_options']['author']) && $values['subscribe_options']['author'] == $uid) {
      unset($uids[$uid]);
      continue;
    }
    // Add internal notifier if it's not added yet.
    if (!isset($options['notifiers']['internal'])) {
      $uids[$uid]['notifiers']['internal'] = 'internal';
    }
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Handles message-user instance deletion when message is being deleted.
 */
function newsfeed_entity_delete($entity, $entity_type) {
  if ($entity_type == 'message') {
    newsfeed_remove($entity->mid);
  }
}

/**
 * Implements hook_forms().
 */
function newsfeed_forms($form_id, $args) {
  $forms = array();
  if (strpos($form_id, 'newsfeed_message_status_form_') === 0) {
    $forms[$form_id] = array(
      'callback' => 'newsfeed_message_status_form',
      'callback arguments' => $args,
    );
  }
  return $forms;
}

/**
 * Form for setting message status.
 */
function newsfeed_message_status_form($form, &$form_state, $args) {
  $form = array();
  
  $mid = $args[0];
  $uid = $args[1];
  $status = $args[2];
  
  $form['#prefix'] = '<div id="newsfeed-message-form-wrapper-' . $mid . '">';
  $form['#suffix'] = '</div>';
  $form['#attributes']['class'][] = 'newsfeed-message-form';

  if (is_null($status)) {
    $status = newsfeed_get_message_status($mid, $uid);
  }
  
  $form_state['storage']['mid'] = !isset($form_state['storage']['mid']) ? $mid : $form_state['storage']['mid'];
  $form_state['storage']['uid'] = !isset($form_state['storage']['uid']) ? $uid : $form_state['storage']['uid'];
  $form_state['storage']['status'] = !isset($form_state['storage']['status']) ? $status : $form_state['storage']['status'];
  
  if ($form_state['storage']['status'] == 1) {
    $form['read'] = array(
      '#markup' => '<div class="message-status read"></div>',
    );
  }
  elseif ($form_state['storage']['status'] == 0) {
    $form['new_status'] = array(
      '#type' => 'hidden',
      '#value' => 1,
    );
    $form['unread'] = array(
      '#type' => 'submit',
      '#value' => '',
      '#ajax' => array(
        'callback' => 'newsfeed_message_status_form_js',
        'wrapper' => 'newsfeed-message-form-wrapper',
        'progress' => array('message' => ''),
      ),
      '#attributes' => array('class' => array('message-status', 'unread'), 'title' => t('Mark as read')),
    );
  }
  
  return $form;
}

/** 
 * AJAX callback function for newsfeed_message_status_form().
 */
function newsfeed_message_status_form_js($form, &$form_state) {
  $commands[] = ajax_command_replace('#newsfeed-message-form-wrapper-' . $form_state['storage']['mid'], render($form));
  // Update count for notifications block.
  $new_count = isset($_SESSION['unread_messages_count']) ? $_SESSION['unread_messages_count'] - 1 : newsfeed_get_unread_messages_count($form_state['storage']['uid']) - 1;
  $_SESSION['unread_messages_count'] = $new_count >= 0 ? $new_count : 0;
  $commands[] = ajax_command_replace('#js-newsfeed-unread-count', '<span id="js-newsfeed-unread-count" class="link-inner">' . $new_count . '</span>');
  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Implements hook FORM_ID_submit for newsfeed_message_status_form().
 */
function newsfeed_message_status_form_submit($form, &$form_state) {
  $updated = newsfeed_update_message_status_multiple(array($form_state['storage']['mid']), $form_state['storage']['uid'], $form_state['values']['new_status']);
  if ($updated) {
    $form_state['storage']['status'] = $form_state['values']['new_status'];
  } else {
    watchdog('newsfeed', 'Message #@mid status update failed.', array('@mid' => $form_state['storage']['mid']), WATCHDOG_WARNING);
  }
  $form_state['rebuild'] = TRUE;
}

/**
 * Implements hook_init().
 */
function newsfeed_init() {
  if (arg(2) == 'blog' && is_numeric(arg(1))) {
    global $user;
    newsfeed_update_unread_messages('newsletter', $user->uid, arg(1));
  }
}


/**
 * Implements hook_node_view().
 */
function newsfeed_node_view($node, $view_mode, $langcode) {
  if ($node->type == 'question' || $node->type == 'open_question') {
    global $user;
    newsfeed_update_unread_messages($node->type, $user->uid, $node->nid);
  }
}

/**
 * Finds related unread messages and updates their status.
 * 
 * @param string $type
 *   Node type.
 * @param integer $uid
 *   User ID.
 * @param integer $nid
 *   Node ID.
 */
function newsfeed_update_unread_messages($type, $uid, $nid) {
  $field = FALSE;
  if ($type == 'question') {
    $field = 'field_message_question';
  }
  elseif ($type == 'open_question') {
    $field = 'field_message_open_question';
  }
  elseif ($type == 'newsletter') {
    $field = 'field_course';
  }
  $unread_messages = newsfeed_get_related_unread_messages($field, $uid, $nid);
  if ($unread_messages) {
    $updated = newsfeed_update_message_status_multiple($unread_messages, $uid, 1);
    if ($updated) {
      $_SESSION['unread_messages_count'] = isset($_SESSION['unread_messages_count']) ? $_SESSION['unread_messages_count'] - count($unread_messages) : newsfeed_get_unread_messages_count($uid);
    }
  }
}

/**
 * Collects related unread messages.
 * 
 * @param string $field
 *   Message field name.
 * @param integer $uid
 *   User ID.
 * @param integer $nid
 *   Node ID.
 */
function newsfeed_get_related_unread_messages($field, $uid, $nid) {
  if (!$field) {
    return FALSE;
  }
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'message')
    ->fieldCondition($field, 'target_id', $nid)
    ->addMetaData('message_uid', $uid)
    ->addTag('newsfeed_related_message');
  $result = $query->execute();
  if ($result) {
    $result = array_keys($result['message']);
  }
  return !empty($result) ? $result : FALSE;
}

/**
 * Implements hook_query_TAG_alter() for 'newsfeed_related_message' tag.
 * 
 * Adds join for 'message_user' table in order to get user related messages.
 */
function newsfeed_query_newsfeed_related_message_alter(QueryAlterableInterface $query) {
  $query->join('message_user', 'mu', $query->getMetaData('base_table') . '0.entity_id = mu.mid');
  $query->condition('mu.uid', $query->getMetaData('message_uid'))
  ->condition('mu.status', 0);
}
