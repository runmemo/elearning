<?php

/**
 * @file course.module
 * Code for the Course module.
 */
include_once 'course.features.inc';

/**
 * Implements hook_hook_info().
 */
function course_hook_info() {
  
  $hooks['block_info']['group'] = 'block';
  $hooks['block_view']['group'] = 'block';
  
}

/**
 *  Implements hook_menu() for course module.
 */
function course_menu() {
  $items['course-exit/%ctools_js/%user/%node'] = array(
    'title' => 'Exit Course',
    'page arguments' => array(1, 2, 3),
    'page callback' => 'course_leave_modal',
    'access callback' => 'user_edit_access',
    'access arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  $items['course-exit-action/%ctools_js/%/%user/%node'] = array(
    'title' => 'Action',
    'page arguments' => array(1, 2, 3, 4),
    'page callback' => 'course_exit_action',
    'access callback' => 'user_edit_access',
    'access arguments' => array(3),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['admin/course/help'] = array(
    'title' => 'Course help',
    'page callback' => 'course_help_index_page',
    'access arguments' => array('view advanced help index'),
    'weight' => 9,
  );
  $items['rate-course/%node/%user'] = array(
    'title' => 'Rate Course',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_course_rating_form', 1, 2),
    'access callback' => TRUE,
    'type' => MENU_NORMAL_ITEM,
    'modal' => TRUE,
  );
  return $items;
}

/**
 * Menu callback for module's help.
 */
function course_help_index_page() {
  $output = theme('advanced_help_topic', array(
    'module' => 'course',
    'topic' => 'introduction',
  ));
  $output .= '&nbsp;' . t('Index of the help page for course functionality.');
  return $output;
}

/**
 * Implementation of hook_menu_alter().
 */
function course_menu_alter(&$items) {
  $items['flag/confirm/%/%flag/%']['modal'] = TRUE;

  // Restrict access to node outline to users who have edit access.
  $items['node/%node/outline']['access callback'] = 'node_access';
  $items['node/%node/outline']['access arguments'] = array('update', 1);

  // Disable page 'node'
  $items['node']['page callback'] = 'drupal_not_found';
  $items['node']['access callback'] = FALSE;
}

/**
 * Gets node last visited by the user
 * @todo test case
 * @param integer $nid id of the node in the book in which
 *                     we will look for last visited node.
 */
function course_last_visited_node($nid, $uid = NULL) {
  if (!isset($uid)) {
    global $user;
    $uid = $user->uid;
  }

  if ($uid == 0) {
    return $nid;
  }

  $sql = 'SELECT h.nid AS nid 
          FROM {history} h 
          INNER JOIN {book} b ON h.nid = b.nid
          INNER JOIN {book} c ON b.bid = c.bid
          INNER JOIN {menu_links} ml ON ml.mlid = b.mlid
          WHERE 
            c.nid = :nid
            AND h.uid = :uid
            AND ml.plid != 0
          ORDER BY h.timestamp DESC
          LIMIT 1';

  $result = db_query($sql, array(':nid' => $nid, ':uid' => $uid));

  foreach ($result as $record) {
    return $record->nid;
  }
  // user did not open any content this course
  return FALSE;
}


/**
 * Gets the href to the first node of specified type in the book
 * 
 * @param string $node_type
 *   Bundle name of the node href of is needed
 * 
 * @return href of the node
 */
function course_first_node_href($node_type, $book = NULL) {
  if (is_null($book)) {
    $book = course_node_book();
  }
  if (!$book) {
    return FALSE;
  }
  $item = $book;
  do {
    $node = menu_get_object('node', 1, $item['link_path']);
    if ($node->type === $node_type) {
      return $item['href'];
    }
    $item = book_next($item);
  } while ($item);
  return FALSE;
}

/**
 * Checks to see if current node is part of a book.
 * Returns book array if it is part of a book, FALSE is not.
 */
function course_node_book() {
  $node = menu_get_object();
  return _node_get_book($node);
}

function _node_get_book($node) {
  if ($node && isset($node->book)) {
    return $node->book;
  }
  return FALSE;
}

/**
 * Implements hook_theme().
 */
function course_theme() {
  return array(
    'course_header' => array(
      'variables' => array('book_link' => NULL),
      'template' => 'course-header',
      'file' => 'course.pages.inc',
    ),
    'course_leave_modal' => array(
      'variables' => array('vars' => NULL),
      'template' => 'course-leave-modal',
      'file' => 'course.pages.inc',
    ),
  );
}

/**
 * Implements hook_node_view().
 */
function course_node_view($node, $view_mode) {
  //unset Book Links
  hide($node->content['links']['book']);
  
  // Redirect to fist lesson from unit content type page
  if ($node->type === 'unit' && $view_mode == 'full') {
    $book_link = $node->book;
    $next = book_next($book_link);
    if ($next) { // there is a lesson ahead
      drupal_goto($next['link_path'], array(), 301);
    }
    else {
      // @todo unit does not have any lessons, so we need to show something     
    }
  }

  // add fields from referenced nodes to content
  if ($view_mode == 'full' && $node->type == 'course') {
    
    $provider = field_get_items('node', $node, 'field_provider');
    if ($provider) {
      
      $field_logo = field_view_field('node', $provider[0]['entity'], 'field_logo', array('label' => 'hidden', 'settings' => array('image_style' => 'provider_logo')));
      if (empty($field_logo)) {
        $node->provider['logo'] = '<div class="provider-logo-default"></div>';
      }
      else {
        $node->provider['logo'] = render($field_logo);
      }
      $field_extra = field_view_field('node', $provider[0]['entity'], 'field_provider_extra', array('label' => 'hidden'));
      $node->provider['extra'] = render($field_extra);
      $node->provider['name'] = $provider[0]['entity']->title;
    }

    // teacher logo and name
    $teacher = field_get_items('node', $node, 'field_teacher');
    $node->teacher = array();
    if ($teacher) {
      // Get teacher's avatar and name.
      $teacher_account = user_load($teacher[0]['uid']);
      $node->teacher['avatar'] = theme('user_picture', array('account' => $teacher_account));
      $node->teacher['teacher_name'] = format_username($teacher_account);
    }
    else {
      $node->teacher['avatar'] = '';
      $node->teacher['teacher_name'] = '';
    }
    if (module_exists('registration')) {
      $node->content['form_class_participate'] = drupal_get_form('course_registration_form');
    }
    else {
     // dvm(book_next($node->book));
      $next = book_next($node->book);
      $node->content['form_class_participate'] = l('Go to class', $next['href']);
    }
  }

  if ($node->type !== 'lesson' && $view_mode === 'full') {
    if (isset($node->content['book_navigation'])) {
      unset($node->content['book_navigation']);
    }
  }
}
  
/**
 * Implementation of hook_views_pre_render().
 * @param type $view
 */
function course_views_pre_render(&$view) {
  if ($view->name != 'user_courses' || empty($view->result)) {
    return NULL; // wrong view or view is empty;
  }

  global $user;
  // Course exit confirmation uses ctools modal.
  // Include the CTools tools that we need.
  ctools_include('ajax');
  ctools_include('modal');
  // Add CTools' javascript to the page.
  ctools_modal_add_js();

  foreach ($view->result as $id => $course) {
    if (!is_numeric($course->node_registration_nid)) {
      continue;
    }
    // get path for the "Continue" link on Profile page
    $last_nid = course_last_visited_node($course->node_registration_nid);
    $path = '';
    if ($last_nid) {
      $path = 'node/' . $last_nid;
    }
    else {
      $node = node_load($course->node_registration_nid);
      $next = book_next($node->book);
      $path = $next['link_path'];
    }
    $account = user_load(arg(1));
    if (user_edit_access($account)) {
      $view->result[$id]->continue_link = l(t('Continue'), $path, array('attributes' => array('class' => 'user-course-continue')));
      $view->result[$id]->exit_link = ctools_modal_text_button('', "course-exit/nojs/{$user->uid}/{$course->node_registration_nid}", t('Exit Course'), 'ctools-modal-common-modal-style user-course-exit');
    }
    else {
      $view->result[$id]->continue_link = '';
      $view->result[$id]->exit_link = '';
    }
    $view->result[$id]->course_progress = course_get_progress($course->node_registration_nid);
  }
}

/**
 * Get course progress
 * @param integer $course_nid nid of the course node
 * @param object $account account of the user for who we check progress
 * @return integer Progress of course completion in percents of total course items
 */
function course_get_progress($course_nid = FALSE, $account = FALSE) {
  if (!$course_nid) {
    return; // course needs to be passed.
  }
  if (!$account) {
    global $user;
    $account = $user;
  }
  $course = node_load($course_nid);
  $items = course_get_items($course);
  $counter = new multi_counter();
  $flag = flag_get_flag('course_item_complete');
  foreach ($items as $nid => $node_type) {
    $counter->increment('items');
    if ($flag->is_flagged($nid, $account->uid)) {
      $counter->increment('completed');
    }
  }
  if ($counter->current('items') != 0) {
    return round(($counter->current('completed') / $counter->current('items')) * 100);
  }

  return 0;
}

/**
 * Internal function that gets array with nids of course items.
 * 
 * Should only be used in course_get_items().
 * 
 * @param array $tree 
 *   Array with menue tree structure of the course book.
 * 
 * @return array 
 *   List of course itmes.
 */
function _course_get_tree_items($tree, $load_type = FALSE) {
  $items = array();
  $tree_key = key($tree);
  if (!isset($tree[$tree_key]['below'])) {
    return $items;
  }
  $units = $tree[$tree_key]['below'];
  foreach ($units as $unit) {
    if (!isset($unit['below'])) {
      continue;
    }
    foreach ($unit['below'] as $item) {
      $nid = str_ireplace('node/', '', $item['link']['link_path']);
      $items[$nid] = $nid;
    }
  }
  return $items;
}

/**
 * Gets all items that are part of the course.
 * 
 * This function should be used intead of _course_get_tree_items()
 * as it provides caching.
 * 
 * @param object $course_item
 *   Node that is part of the course book.
 * 
 * @return array 
 *   Array of nids of nodes that are part of the course.
 */
function course_get_items($course_item) {
  if(!isset($course_item->book)) {
    return array();
  }
  // Check if values exist in cache (cache item per book). 
  if ($cached = cache_get('course_get_items_' . $course_item->book['bid'])) {
    return $cached->data;
  }
 
  // Get items from the course book.
  $tree = menu_tree_all_data($course_item->book['menu_name'], NULL, 3);
  $items = _course_get_tree_items($tree);
  $res = array();
  foreach ($items as $nid => $item) {
    $res[$nid] = course_get_node_type($nid);
  }

  // Set chache.
  cache_set('course_get_items_' . $course_item->book['bid'], $res, 'cache', 60 * 60);
  return $res;
}

/**
 * Workarround function to avoid infinite loop with node_load.
 * 
 * @param integer $nid
 *   Node's nid.
 * 
 * @return string
 *   Type of the node.
 */
function course_get_node_type($nid) {
  // Cache results for current page load.
  $type = &drupal_static(__FUNCTION__);
  if (isset($type)) {
    return $type;
  }
  // Get node type for the database directly rather than node_load!
  $res = db_select('node', 'n')
          ->fields('n', array('type'))
          ->condition('n.nid', $nid)
          ->execute()->fetch();
  if ($res) {
    return $res->type;
  }
  else {
    return FALSE;
  }
}

function course_is_item_node($node) {
  if (!isset($node->book)) {
    return FALSE;
  }
  return in_array($node->type, course_item_node_types());
}

/**
 * Gets content types that are supported as items of the course.
 * @return array
 */
function course_item_node_types() {

  $items = &drupal_static(__FUNCTION__);

  if (!isset($items)) {
    // array that matches modules to content types that they add
    $modules = array(
      'lesson' => 'lesson',
      'quiz' => 'quiz',
      'open_question' => 'open_question',
      'closedquestion' => 'closedquestion',
    );
    $items = array();

    // add content types provided by modules
    foreach ($modules as $module => $bundle) {
      if (module_exists($module)) {
        $items[] = $bundle;
      }
    }
  }

  return $items;
}

function course_exit_action($js = NULL, $action = 'cancel', $user = NULL, $course = NULL) {
  if (!$js) {
    // we should never be here out of ajax context
    return MENU_NOT_FOUND;
  }

  ctools_include('ajax');
  ctools_add_js('ajax-responder');
  ctools_include('modal');
  $commands = array();

  switch ($action) {
    case 'cancel':
      $commands[] = ctools_modal_command_dismiss();
      break;
    case 'exit':
      if (registration_cancel($user->uid, $course->nid)) {
        drupal_set_message(t('Successful de-registered from course.'));
      }
      else {
        drupal_set_message(t('No registration was found, looks like list of cousrse is wrong'), 'error');
      }
      $commands[] = ctools_ajax_command_reload();
      break;
  }

  print ajax_render($commands);
  exit;
}

function course_leave_modal($js = NULL, $user = NULL, $course = NULL) {
  if ($course == NULL || $user == NULL) {
    return 'Error :: No course node or user uid.';
  }
  if (!$js) {
    //@todo bulat : Do we need to support non-js calls also ?
    return;
  }
  else {
    // Required includes for ctools to work:
    ctools_include('modal');
    ctools_include('ajax');
  }

  return ctools_modal_render(t('Confirmation'), theme('course_leave_modal', array('uid' => $user->uid, 'course' => $course)));
}

/**
 *  Implements of hook_node_access()
 */
function course_node_access($node, $op, $account) {
  // @todo allow teachers to create new course, lessson, etc.
  if (($op == 'update' || $op == 'delete') &&
      (course_is_item_node($node) || in_array($node->type, array('course', 'unit')))) {
    if (course_is_teacher($node, $account)) {
      return NODE_ACCESS_ALLOW;
    }
    return NODE_ACCESS_IGNORE;
  }
}

/**
 * Checks if user is a teacher for the course to which node belongs.
 */
function course_is_teacher($node, $account) {
  if (is_null($node) || !isset($node->book)) {
    return FALSE;
  }
  // Compare uid of course teacher and account.
  $item = entity_metadata_wrapper('node', $node);
  $teacher = $item->book->field_teacher->raw();
  if ($teacher == $account->uid) {
    // Account is a teacher of the course.
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Gets course grades as an array from field_grades on Course node.
 * 
 * @param object $course 
 *   Course node.
 * 
 * @return array 
 *   Grades array sorted by score or FALSE if field does not exist or is empty.
 */
function course_get_course_grades($course) {
  if ($cached = cache_get('course_grades_' . $course->nid, 'cache')) {
    $grades = $cached->data;
    return $grades;
  }
  $node_wrapper = entity_metadata_wrapper('node', $course);
  if (!isset($node_wrapper->field_grades)) {
    return FALSE;
  }
  // Populate grades with values from the field.
  $grades = array();
  foreach ($node_wrapper->field_grades as $key => $grade) {
    $score = $grade->field_grade_score->raw();
    $description = $grade->field_grade_name->raw();
    $grades[$score] = $description;
  }
  if (empty($grades)) {
    return FALSE;
  }
  ksort($grades, SORT_NUMERIC);
  cache_set('course_grades_' . $course->nid, $grades, 'cache', 24 * 60 * 60); //1 hour
  return $grades;
}

/**
 * Gets associative array of grade ranges for the course e.g.:
 *   - 0-50 => Certificate is not availabe
 *   - 50-70 => Pass
 *   - > 70 => Distinction
 * 
 * @param object $course
 * 
 * @return array
 *   Array as described above.
 */
function course_get_grade_ranges($grades) {
  if (!$grades || empty($grades)) {
    return FALSE;
  }
  $grade_ranges = array();
  $prev_score = 0;
  $prev_desc = t('Certificate is not available');

  // Create array of score ranges with grade names.
  foreach ($grades as $score => $grade_name) {
    $range = $prev_score . '-' . ($score - 1);
    $grade_ranges[$range] = $prev_desc;
    $prev_score = $score;
    $prev_desc = $grade_name;
  }
  $max_score = $prev_score;
  $range = $max_score . '+';
  $grade_ranges[$range] = $grades[$max_score];
  return $grade_ranges;
}

/**
 * Gets pass rate for the course from the grades field. 
 * 
 * Pass value equals to the minimum score of all grades.
 * 
 * @param object $course
 *   Course node.
 * 
 * @return int
 *   Minim score required to qualify for certificate or pass.
 */
function course_get_course_pass_score($course) {
  $grades = course_get_course_grades($course);
  if ($grades) {
    reset($grades);
    return key($grades);
  }
  else {
    return 0;
  }
}

/**
 * Implements hook_access_certificate() from certificate module.
 */
function course_access_certificate($node, $user) {
  if ($node->type !== 'course') {
    return t('This is not a course, certificate is not available.');
  }
  $pass_score = course_get_course_pass_score($node);
  $user_credit = credit_calculate($node, $user);
  // User must have more credit poits than a pass value on the course.
  return $user_credit >= $pass_score;
}

/**
 * Implements hook_user_update().
 */
function course_user_update(&$edit, $account, $category) {
  if (!empty($account->logintoboggan_email_validated)) {
    // Get role object for student.
    $role = user_role_load_by_name('student');

    // Save the user object with the student role.
    if (!isset($account->roles[$role->rid])) {
      $edit['roles'] = $account->roles + array($role->rid => $role->name);
      user_save($account, $edit);
    }
  }
}

/**
 *  Implements hook_form_FORM_ID_alter.
 *  Hide book outline form, from non course item content type nodes.
 */
function course_form_book_outline_form_alter(&$form, &$form_state) {
  $node = menu_get_object('node');

  if (!in_array($node->type, course_item_node_types())) {
    $form['#access'] = FALSE;
  }
}

/**
 * Form for setting course rating.
 * 
 * @param object $course
 *   Course object
 * @param object $user
 *   User object
 * 
 */
function course_course_rating_form($form, &$form_state, $course, $user) {
  $form = array();
  $form['#attributes']['class'][] = 'course-rating-form';
  if (!course_registration_id($user->uid, $course->nid)) {
    $form['msg'] = array(
      '#markup' => t('Please, register to the !course.', array('!course' => l(t('course'), 'course/' . $course->nid))),
    );
    return $form;
  }
  if (!isset($form_state['feedback_nid'])) {
    $form_state['feedback_nid'] = course_is_reviewed($course->nid, $user->uid);
  }
  if ($form_state['feedback_nid']) {
    $form_state['mode'] = 'update';
    $feedback_wrapper = entity_metadata_wrapper('node', $form_state['feedback_nid']);
    $rating = $feedback_wrapper->field_rating->raw();
    $body = $feedback_wrapper->body->value();
    $review = $body['value'];
  }
  else {
    $form_state['mode'] = 'insert';
  }
  
  $form['rating'] = array(
    '#type' => 'fivestar',
    '#title' => t('Rating'),
    '#required' => TRUE,
    '#default_value' => isset($rating) ? $rating : NULL,
  );
  $form['review'] = array(
    '#type' => 'textarea',
    '#title' => t('Review'),
    '#required' => FALSE,
    '#default_value' => isset($review) ? $review : '',
  );
  $form['rating_submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );
  
  return $form;
}

/**
 * Implements hook FORM_ID_submit for course_course_rating_form().
 */
function course_course_rating_form_submit($form, &$form_state) {
  if ($form_state['mode'] == 'update') {
    $node = node_load($form_state['feedback_nid']);
    if ($node) {
      $lang = $node->language;
      $node->body[$lang][0]['value'] = $form_state['values']['review'];
      $node->field_rating[$lang][0]['rating'] = $form_state['values']['rating'];
      node_save($node);
    }
  }
  else {
    $course_nid = $form_state['build_info']['args'][0]->nid;
    $uid = $form_state['build_info']['args'][1]->uid;
    $node = new stdClass();
    $node->type = 'course_feedback';
    node_object_prepare($node);
    $node->title = 'Course feedback nid#' . $course_nid . '# uid#' . $uid;
    $node->language = LANGUAGE_NONE;
    $node->body[$node->language][0]['value'] = $form_state['values']['review'];
    $node->field_course[$node->language][0]['target_id'] = $course_nid;
    $node->field_rating[$node->language][0]['rating'] = $form_state['values']['rating'];
    node_save($node);
  }
}

/**
 * Determines wither course was reviewed by the user.
 * 
 * @param integer $nid
 *   Node ID of the course
 * @param integer $uid
 *   User ID of the user
 * 
 * @return integer
 *   ID of the feedback node if exists, otherwise FALSE
 */
function course_is_reviewed($nid, $uid = NULL) {
  if (is_null($uid)) {
    global $user;
    $uid = $user->uid;
  }
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'course_feedback')
      ->propertyCondition('status', 1)
      ->propertyCondition('uid', $uid)
      ->fieldCondition('field_course', 'target_id', $nid)
      ->range(0, 1);

  $result = $query->execute();

  foreach ($result as $entity_type => $entities) {
    foreach ($entities as $entity_id => $entity) {
      return $entity_id;
    }
  }
  return FALSE; 
}

/**
 * Calculates average rating for the course.
 * 
 * @param integer $course_nid
 *   Node ID of the course
 * 
 * @return float
 *   Average course rating
 */
function course_get_course_rating($course_nid) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'course_feedback')
    ->propertyCondition('status', 1)
    ->fieldCondition('field_course', 'target_id', $course_nid);
  $result = $query->execute();
  if (empty($result)) {
    return 0;
  }
  $sum = 0;
  foreach ($result['node'] as $nid => $node) {
    $wrapper = entity_metadata_wrapper('node', $nid);
    $sum = $sum + $wrapper->field_rating->value();
  }
  if ($sum == 0) {
    return 0;
  }
  return $sum / count($result['node']);
}
